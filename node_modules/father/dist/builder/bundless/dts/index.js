"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTsconfig = void 0;
const utils_1 = require("@umijs/utils");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const typescript_transform_paths_1 = __importDefault(require("typescript-transform-paths"));
const constants_1 = require("../../../constants");
const utils_2 = require("../../../utils");
/**
 * get parsed tsconfig.json for specific path
 */
function getTsconfig(cwd) {
    // use require() rather than import(), to avoid jest runner to fail
    // ref: https://github.com/nodejs/node/issues/35889
    const ts = require('typescript');
    const tsconfigPath = ts.findConfigFile(cwd, ts.sys.fileExists);
    if (tsconfigPath) {
        const tsconfigFile = ts.readConfigFile(tsconfigPath, ts.sys.readFile);
        return ts.parseJsonConfigFileContent(tsconfigFile.config, ts.sys, path_1.default.dirname(tsconfigPath));
    }
}
exports.getTsconfig = getTsconfig;
/**
 * get declarations for specific files
 */
async function getDeclarations(inputFiles, opts) {
    const cache = (0, utils_2.getCache)('bundless-dts');
    const enableCache = process.env.FATHER_CACHE !== 'none';
    const tscCacheDir = path_1.default.join(opts.cwd, constants_1.CACHE_PATH, 'tsc');
    if (enableCache) {
        // make tsc cache dir
        utils_1.fsExtra.ensureDirSync(tscCacheDir);
    }
    const output = [];
    // use require() rather than import(), to avoid jest runner to fail
    // ref: https://github.com/nodejs/node/issues/35889
    const ts = require('typescript');
    const tsconfig = getTsconfig(opts.cwd);
    if (tsconfig) {
        // check tsconfig error
        /* istanbul ignore if -- @preserve */
        if (tsconfig.errors.length) {
            throw new Error(`Error parsing tsconfig.json content: ${utils_1.chalk.redBright(ts.flattenDiagnosticMessageText(tsconfig.errors[0].messageText, '\n'))}`);
        }
        // warn if noEmit is false
        /* istanbul ignore if -- @preserve */
        if (tsconfig.options.declaration && tsconfig.options.noEmit === true) {
            utils_2.logger.warn('tsconfig.json `noEmit` is true, will not emit declaration files!');
            return output;
        }
        // enable declarationMap by default in development mode
        if (process.env.NODE_ENV === 'development' &&
            tsconfig.options.declaration &&
            tsconfig.options.declarationMap !== false) {
            tsconfig.options.declarationMap = true;
        }
        // remove paths which out of cwd, to avoid transform to relative path by ts-paths-transformer
        Object.keys(tsconfig.options.paths || {}).forEach((item) => {
            const pathAbsTarget = path_1.default.resolve(tsconfig.options.pathsBasePath, tsconfig.options.paths[item][0]);
            if (!(0, utils_1.winPath)(pathAbsTarget).startsWith(`${(0, utils_1.winPath)(opts.cwd)}/`)) {
                delete tsconfig.options.paths[item];
                utils_2.logger.debug(`Remove ${item} from tsconfig.paths, because it's out of cwd.`);
            }
        });
        // enable incremental for cache
        if (enableCache && typeof tsconfig.options.incremental === 'undefined') {
            tsconfig.options.incremental = true;
            tsconfig.options.tsBuildInfoFile = path_1.default.join(tscCacheDir, 'tsconfig.tsbuildinfo');
        }
        const tsHost = ts.createIncrementalCompilerHost(tsconfig.options);
        const cacheKeys = inputFiles.reduce((ret, file) => ({
            ...ret,
            // format: {path:mtime:config}
            [file]: [
                file,
                fs_1.default.lstatSync(file).mtimeMs,
                JSON.stringify(tsconfig.options),
            ].join(':'),
        }), {});
        const cacheRets = {};
        tsHost.writeFile = (fileName, content, _a, _b, sourceFiles) => {
            var _c;
            const sourceFile = sourceFiles === null || sourceFiles === void 0 ? void 0 : sourceFiles[0].fileName;
            if (fileName === tsconfig.options.tsBuildInfoFile) {
                // save incremental cache
                utils_1.fsExtra.writeFileSync(tsconfig.options.tsBuildInfoFile, content);
            }
            else if (sourceFile) {
                // write d.ts & d.ts.map and save cache
                const ret = {
                    file: path_1.default.basename(fileName),
                    content,
                    sourceFile,
                };
                // only collect dts for input files, to avoid output error in watch mode
                // ref: https://github.com/umijs/father-next/issues/43
                if (inputFiles.includes(sourceFile)) {
                    const index = output.findIndex((out) => out.file === ret.file && out.sourceFile === ret.sourceFile);
                    if (index > -1) {
                        output.splice(index, 1, ret);
                    }
                    else {
                        output.push(ret);
                    }
                }
                // group cache by file (d.ts & d.ts.map)
                // always save cache even if it's not input file, to avoid cache miss
                // because it probably can be used in next bundless run
                const cacheKey = cacheKeys[sourceFile] ||
                    [
                        sourceFile,
                        fs_1.default.lstatSync(sourceFile).mtimeMs,
                        JSON.stringify(tsconfig.options),
                    ].join(':');
                (_c = cacheRets[cacheKey]) !== null && _c !== void 0 ? _c : (cacheRets[cacheKey] = []);
                cacheRets[cacheKey].push(ret);
            }
        };
        // use cache first
        inputFiles.forEach((file) => {
            const cacheRet = cache.getSync(cacheKeys[file], '');
            if (cacheRet) {
                output.push(...cacheRet);
            }
        });
        const incrProgram = ts.createIncrementalProgram({
            rootNames: inputFiles,
            options: tsconfig.options,
            host: tsHost,
        });
        // using ts-paths-transformer to transform tsconfig paths to relative path
        // reason: https://github.com/microsoft/TypeScript/issues/30952
        // ref: https://www.npmjs.com/package/typescript-transform-paths
        const result = incrProgram.emit(undefined, undefined, undefined, true, {
            afterDeclarations: [
                (0, typescript_transform_paths_1.default)(incrProgram.getProgram(), { afterDeclarations: true }, 
                // specific typescript instance, because this plugin is incompatible with typescript@4.9.x currently
                // but some project may declare typescript and some dependency manager will hoist project's typescript
                // rather than father's typescript for this plugin
                { ts }),
            ],
        });
        // check compile error
        // istanbul-ignore-if
        if (result.diagnostics.length) {
            result.diagnostics.forEach((d) => {
                const loc = ts.getLineAndCharacterOfPosition(d.file, d.start);
                const rltPath = (0, utils_1.winPath)(path_1.default.relative(opts.cwd, d.file.fileName));
                const errMsg = ts.flattenDiagnosticMessageText(d.messageText, '\n');
                utils_2.logger.error(`${utils_1.chalk.blueBright(rltPath)}:${
                // correct line number & column number, ref: https://github.com/microsoft/TypeScript/blob/93f2d2b9a1b2f8861b49d76bb5e58f6e9f2b56ee/src/compiler/tracing.ts#L185
                `${utils_1.chalk.yellow(loc.line + 1)}:${utils_1.chalk.yellow(loc.character + 1)}`} - ${utils_1.chalk.gray(`TS${d.code}:`)} ${errMsg}`);
            });
            throw new Error('Declaration generation failed.');
        }
        // save cache
        Object.keys(cacheRets).forEach((key) => cache.setSync(key, cacheRets[key]));
    }
    return output;
}
exports.default = getDeclarations;
